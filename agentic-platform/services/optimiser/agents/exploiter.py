"""
Exploiter agents that refine promising regions of the search space.

Exploiters perform local search around good configurations to find
local optima. They typically spawn from Explorers that find promising areas.
"""

from dataclasses import dataclass, field
from typing import TYPE_CHECKING

import numpy as np

from agents.base import Agent

if TYPE_CHECKING:
    from orchestration import Blackboard
    from search_space import SearchSpace


@dataclass
class HillClimbExploiter(Agent):
    """
    Local search agent using gaussian perturbation with shrinking step size.

    Starts at a promising position and performs hill climbing by:
    1. Perturbing current position with gaussian noise
    2. Moving to new position if it improves the score
    3. Shrinking step_size on each improvement (annealing)
    4. Dying when step_size is too small or stagnation occurs

    Exploiters are leaf nodes - they do not spawn children.

    Attributes:
        id: Unique identifier (inherited)
        position: Current best position (inherited)
        history: All (config, score) pairs (inherited)
        alive: Whether agent is active (inherited)
        generation: Generation number in genealogy (inherited)
        parent_id: ID of parent agent (inherited)
        initial_position: Starting position from parent's discovery
        step_size: Current perturbation magnitude (fraction of dimension range)
        min_step_size: Minimum step_size before death
        stagnation_counter: Iterations without improvement
        max_stagnation: Maximum stagnation before death

    Example:
        >>> exploiter = HillClimbExploiter(
        ...     id="exploiter-1",
        ...     initial_position={"x": 0.5, "y": 0.5},
        ... )
        >>> config = exploiter.propose_next(space, blackboard)
    """

    initial_position: dict[str, float | int] = field(default_factory=dict)
    step_size: float = field(default=0.1)
    min_step_size: float = field(default=0.001)
    stagnation_counter: int = field(default=0, repr=False)
    max_stagnation: int = field(default=5, repr=False)
    _local_best_score: float | None = field(default=None, init=False, repr=False)
    _rng: np.random.Generator = field(init=False, repr=False)
    _seed: int | None = field(default=None, repr=False)

    def __post_init__(self) -> None:
        """Initialize position and random generator."""
        self._rng = np.random.default_rng(self._seed)
        # Start at initial_position
        if self.initial_position and self.position is None:
            self.position = self.initial_position.copy()

    def propose_next(
        self,
        search_space: "SearchSpace",
        blackboard: "Blackboard | None" = None,
    ) -> dict[str, float | int]:
        """
        Propose a gaussian perturbation of the current position.

        Perturbs each dimension by gaussian noise scaled by step_size
        and the dimension's range. Clamps to valid bounds.

        Args:
            search_space: The space to sample from
            blackboard: Optional blackboard (unused but required by interface)

        Returns:
            A perturbed configuration
        """
        if self.position is None:
            # Fallback: use initial_position or sample random
            if self.initial_position:
                self.position = self.initial_position.copy()
            else:
                return search_space.sample_random(self._rng)

        new_config: dict[str, float | int] = {}

        for name in search_space.dim_names:
            dim = search_space.dimensions[name]
            current_val = self.position[name]

            if dim.dim_type == "continuous":
                # Gaussian perturbation scaled by range and step_size
                range_size = dim.high - dim.low
                if dim.log_scale:
                    # Perturb in log space
                    log_val = np.log(current_val)
                    log_range = np.log(dim.high) - np.log(dim.low)
                    delta = self._rng.normal(0, self.step_size * log_range)
                    new_log_val = np.clip(
                        log_val + delta, np.log(dim.low), np.log(dim.high)
                    )
                    new_config[name] = float(np.exp(new_log_val))
                else:
                    delta = self._rng.normal(0, self.step_size * range_size)
                    new_val = np.clip(current_val + delta, dim.low, dim.high)
                    new_config[name] = float(new_val)

            elif dim.dim_type == "integer":
                # Discrete perturbation: random step of -1, 0, or +1
                # Probability of change scales with step_size
                if self._rng.random() < self.step_size * 10:
                    delta = self._rng.choice([-1, 1])
                else:
                    delta = 0
                new_val = int(np.clip(current_val + delta, dim.low, dim.high))
                new_config[name] = new_val

        return new_config

    def update(
        self,
        config: dict[str, float | int],
        score: float,
        blackboard: "Blackboard | None" = None,
    ) -> None:
        """
        Update state after evaluation.

        If score improves:
          - Move position to new config
          - Reset stagnation counter
          - Shrink step_size (annealing)
        Otherwise:
          - Increment stagnation counter

        Args:
            config: The evaluated configuration
            score: The objective value (lower is better)
            blackboard: Optional blackboard to post evaluation to
        """
        self.history.append((config, score))

        # Check for improvement (minimization: lower is better)
        if self._local_best_score is None or score < self._local_best_score:
            self._local_best_score = score
            self.position = config.copy()
            self.stagnation_counter = 0
            # Annealing: shrink step size on improvement
            self.step_size *= 0.9
        else:
            self.stagnation_counter += 1

        if blackboard is not None:
            blackboard.post_evaluation(config, score, self.id)

    def should_die(self) -> bool:
        """
        Die when step_size is too small or stagnation limit reached.

        Returns:
            True if step_size < min_step_size or stagnation_counter >= max_stagnation
        """
        if self.step_size < self.min_step_size:
            return True
        if self.stagnation_counter >= self.max_stagnation:
            return True
        return False

    def should_spawn(self, blackboard: "Blackboard") -> bool:
        """
        Exploiters do not spawn children.

        Returns:
            Always False
        """
        return False

    def create_child(
        self,
        search_space: "SearchSpace",
        child_id: str,
    ) -> "Agent | None":
        """
        Exploiters do not create children.

        Returns:
            Always None
        """
        return None
